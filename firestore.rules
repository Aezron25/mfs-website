/**
 * @file Firebase Security Rules for Mwanakombo Financial Services.
 *
 * @corePhilosophy This ruleset enforces a strict user-ownership model for client profiles and their messages,
 *                 and uses document existence in a dedicated collection to grant admin privileges.
 *                 It prioritizes security and authorization independence through data denormalization.
 *
 * @dataStructure
 *   - /client_profiles/{clientProfileId}: Stores client profile data, accessible only to the authenticated user with a matching UID.
 *   - /client_profiles/{clientProfileId}/messages/{messageId}: Stores messages sent by a client, with the 'clientProfileId' denormalized for authorization.
 *   - /roles_admin/{adminProfileId}: Collection to store admin profiles. Existence of a document grants admin privileges.
 *
 * @keySecurityDecisions
 *   - Only the authenticated user (client) can access their own profile.
 *   - Messages include the clientProfileId, eliminating the need for get() calls to the parent client_profiles document.
 *   - Admin roles are managed through document existence in /roles_admin/{uid}, avoiding custom claims.
 *   - No public listing of any collections is permitted without authentication.
 *
 * @denormalizationForAuthorization
 *   - The `messages` subcollection includes the `clientProfileId`, eliminating the need for `get()` calls to the parent `client_profiles` document.
 *     Security rules can directly verify ownership based on `request.auth.uid` and the `clientProfileId` within the message.
 *
 * @structuralSegregation
 *   - Admin roles are stored in a separate collection (`/roles_admin`) instead of being combined with client profiles.
 *     This clearly separates client profiles, admin roles, and client messages, making authorization intent explicit.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces that only the authenticated user can access their own client profile.
     * @path /client_profiles/{clientProfileId}
     * @allow (get, create, update, delete) if request.auth.uid == clientProfileId
     * @deny (get, create, update, delete) if request.auth.uid != clientProfileId
     * @principle Enforces document ownership for all operations.
     */
    match /client_profiles/{clientProfileId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is the owner of the document
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      // Helper function to check if the user is the existing owner of the document
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      // Reads
      allow get: if isOwner(clientProfileId);
      allow list: if isOwner(clientProfileId);

      // Writes
      allow create: if isOwner(clientProfileId) && request.resource.data.id == clientProfileId;
      allow update: if isExistingOwner(clientProfileId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(clientProfileId);
    }

    /**
     * @description Enforces that only the owner of the client profile can manage their messages.
     * @path /client_profiles/{clientProfileId}/messages/{messageId}
     * @allow (create) if request.auth.uid == clientProfileId
     * @deny (create) if request.auth.uid != clientProfileId
     * @allow (get, list, update, delete) if resource.data.clientProfileId == request.auth.uid
     * @deny (get, list, update, delete) if resource.data.clientProfileId != request.auth.uid
     * @principle Enforces document ownership for all message operations.
     */
    match /client_profiles/{clientProfileId}/messages/{messageId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is the owner of the message
      function isMessageOwner(clientProfileId) {
        return isSignedIn() && request.auth.uid == clientProfileId;
      }

      // Helper function to check if the user is the existing owner of the message
      function isExistingMessageOwner(clientProfileId) {
        return isMessageOwner(clientProfileId) && resource != null;
      }

      // Reads
      allow get: if isMessageOwner(clientProfileId);
      allow list: if isMessageOwner(clientProfileId);

      // Writes
      allow create: if isMessageOwner(clientProfileId) && request.resource.data.clientProfileId == clientProfileId;
      allow update: if isExistingMessageOwner(clientProfileId) && request.resource.data.clientProfileId == resource.data.clientProfileId;
      allow delete: if isExistingMessageOwner(clientProfileId);
    }

    /**
     * @description Grants admin privileges based on the existence of a document in this collection.
     * @path /roles_admin/{adminProfileId}
     * @allow (get, create, update, delete, list) if isAdmin()
     * @deny (get, create, update, delete, list) if !isAdmin()
     * @principle Role-based access control via document existence.
     */
    match /roles_admin/{adminProfileId} {
      // Helper function to check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the user is an admin (document exists)
      function isAdmin() {
        return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }

      // Reads
      allow get: if isAdmin();
      allow list: if isAdmin();

      // Writes
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}